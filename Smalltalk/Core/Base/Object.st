CLASS Object EXTENDS nil MODULE Core CLASSVARS '' VARS ''

INLINE 'import { Naming } from "./Runtime.js";'

CLASSMETHODS

myTest
	"This is the first method compiled, used when testing the compiler."
	| a b |
	a := 1.
	true ifTrue: [
		a increment ].
	^ a.
!

new
	"The basicNew method is generated by the compiler in each class
	 to instantiate ST objects from their generated JS class."
	^ self basicNew.
!
fromJs: js
	"Return new ST object containing values of argument JS object, recursively."

	| jsClassName float object jsObject |

	INLINE 'if( js == null ) return stNil'.

	jsClassName := String fromJs: INLINE 'js.constructor.name'.

	jsClassName = 'String' ifTrue: [
		^ String fromJs: js ].

	jsClassName = 'Number' ifTrue: [
		"Convert to integer if possible, otherwise float."
		float := Float fromJs: js.
		^ float isSafeInteger ifTrue: [ float toInteger ] ifFalse: [ float ] ].

	jsClassName = 'Boolean' ifTrue: [
		^ Boolean fromJs: js ].

	jsClassName = 'Array' ifTrue: [
		^ Array fromJs: js
			elementConverter: [ :element | Object fromJs: element ] ].

	jsClassName = 'Object' ifTrue: [
		object := Object new.
		jsObject := JsObject fromJs: js.
		jsObject ownJsPropertyNames do: [ :name |
			object atProperty: name put: ( jsObject atJsProperty: name ) ].
		^ object ].

	self error: 'Unknown JS classname: ', jsClassName.
!

"JSON"

"21-NOV-2023: The built-in fetch() of Node.js (currently v21.2.0)
 will not sometimes work and cause errors.
 From Node.js, use the fetch: method from the Http class, that is based on the npm package 'node-fetch'"

fetchObject: url then: block onError: errorBlock
	"Retuns a ST object from the the fetched JSON response."
	INLINE '
		fetch( url.js )
			.then( response => response.json() )
			.then( js => block.$value$( stObject$class.$fromJs$( js ) ) )
			.catch( error => errorBlock.$value$( stError$class.$fromJs$( error ) ) )'.
!
parse: json
	^ Object fromJs: INLINE 'JSON.parse( json.js )'.
!

METHODS

"Converting"

toJs
	"Converts self to a JS object.
	 Array overloads this to convert array elements to JS also, recursively.
	 So the resulting object is a JS (not ST) object
	 and is suitable for passing to JS functions, and conversion to JSON."

	| result |

	result := JsObject newEmpty.
	self ownPropertyNames do: [ :name |
		result atJsProperty: name put: ( self atProperty: name ) ].
	^ result js.
!
toJson
	"Return a JSON string representing self."
	^ String fromJs: INLINE 'JSON.stringify( this.$toJs() )'.
!
toJsObject
	"Calls toJs and wraps result in a JsObject."

	^ JsObject fromJs: self toJs.
!
toString
	^ 'a ', self class name.
!
toLocaleString
	^ self toString.
!

"Properties"

ownPropertyNames
	^ Array fromJs: INLINE 'Object.getOwnPropertyNames( this )' elementClass: String.
!
atProperty: name
	^ Nil fromJs: INLINE 'this[ name.js ]'.
!
atProperty: name put: value
	INLINE 'this[ name.js ] = value'.
!

"Comparing"

== object
	"Return true a self and arg refer to the same object."
	^ Boolean fromJs: INLINE 'this === object'.
!
= object
	"Return true a self and arg have the same value.
	 The default is to return object equality.
	 Overload this for composed objects."
	^ self == object.
!
~= object
	^ ( self = object ) not.
!
isNil
	^ false.
!
notNil
	^ self isNil not.
!

"Default cases of (reverse) comparing number types compares to other objects."

argIsEqualToInteger: integer
	^ false.
!
argIsEqualToBigInt: bigInt
	^ false.
!
argIsEqualToFloat: float
	^ false.
!
argIsEqualToFraction: fraction
	^ false.
!

"Error handling"

assert: block
	block value ifFalse: [
		self error: 'Assertion failed: ', block script ].
!
error: message
	Error throw: message.
!
subclassResponsibility
	self error: 'Method should be implemented by subclass.'
!
log: message
	INLINE 'console.log( message.$toString().js )'.
!
yourself
	^ self.
!
halt
	self error: 'Halted.'.
!

"Class testing"

isKindOf: aClass
	^ self class inheritsFrom: aClass.
!
isMemberOf: aClass
	^ self class = aClass.
!

"Methods"

perform: methodName
	^ INLINE 'this[ Naming.methodStToJs( methodName.js ) ]()'.
!
perform: methodName with: argument
	^ INLINE 'this[ Naming.methodStToJs( methodName.js ) ]( argument )'.
!
perform: methodName with: argument1 with: argument2
	^ INLINE 'this[ Naming.methodStToJs( methodName.js ) ]( argument1, argument2 )'.
!
perform: methodName with: argument1 with: argument2 with: argument3
	^ INLINE 'this[ Naming.methodStToJs( methodName.js ) ]( argument1, argument2, argument3 )'.
!

