CLASS Object EXTENDS nil MODULE Core CLASSVARS '' VARS ''

INLINE 'import { Naming } from "./Runtime.js";'

CLASSMETHODS

myTest
	"This is the first method compiled.
	Can be changed when testing the compiler."
	| a |
	a := 1.
!

"Creating"

new
	"The basicNew method is generated by the compiler in each class
	 to instantiate ST objects from their generated JS class."
	^ self basicNew.
!
fromJs: js
	"Return new ST object containing values of argument JS object, recursively."

	| jsType jsClass float object jsObject |

	INLINE 'if( js == null ) return stNil'.

	jsType := String fromJs: INLINE 'typeof js'.

	jsType = 'string' ifTrue: [
		^ String fromJs: js ].

	jsType = 'number' ifTrue: [
		"Convert to integer if possible, otherwise float."
		float := Float fromJs: js.
		^ float isSafeInteger ifTrue: [ float toInteger ] ifFalse: [ float ] ].

	jsType = 'boolean' ifTrue: [
		^ Boolean fromJs: js ].

	( Array isJsArray: js ) ifTrue: [
		^ Array fromJs: js
			elementConverter: [ :element | Object fromJs: element ] ].

	jsType = 'object' ifTrue: [
		( Date isJsDate: js ) ifTrue: [
			^ Date fromJs: js ].
		jsClass := String fromJs: INLINE '( js.constructor ? js.constructor.name : null )'.
		jsClass = 'Uint8Array' ifTrue: [
			^ Uint8Array fromJs: js ].
		"A NodeJS Buffers is also a Uint8Array"
		jsClass = 'Buffer' ifTrue: [
			^ Uint8Array fromJs: js ].

		object := Object new.
		jsObject := JsObject fromJs: js.
		jsObject ownJsPropertyNames do: [ :name |
			object atProperty: name put: ( jsObject atJsProperty: name ) ].
		^ object ].

	self error: 'Unknown JS type: ', jsType.
!
fromJson: json
	^ Object fromJs: INLINE 'JSON.parse( json.js )'.
!

METHODS

"Converting"

toJs
	"Converts self to a JS object.
	 Array overloads this to convert array elements to JS also, recursively.
	 So the resulting object is a JS (not ST) object
	 and is suitable for passing to JS functions, and conversion to JSON."

	| result |

	result := JsObject newEmpty.
	self ownPropertyNames do: [ :name |
		result atJsProperty: name put: ( self atProperty: name ) ].
	^ result js.
!
toJsObject
	"Calls toJs and wraps result in a JsObject."

	^ JsObject fromJs: self toJs.
!
toJson
	"Return a JSON string representing self."
	| jsObject |
	"Separate step to prevent minimizing of method: toJs."
	jsObject := self toJs.
	^ String fromJs: INLINE 'JSON.stringify( jsObject )'.
!
toString
	^ 'a ', self class name.
!
toLocaleString
	^ self toString.
!

"Properties"

ownPropertyNames
	^ Array fromJs: INLINE 'Object.getOwnPropertyNames( this )' elementClass: String.
!
atProperty: name
	^ Nil fromJs: INLINE 'this[ name.js ]'.
!
atProperty: name put: value
	INLINE 'this[ name.js ] = value'.
!
keys
	^ Array fromJs: INLINE 'Object.keys( this )' elementClass: String.
!
entries
	^ Array fromJs: INLINE 'Array.from( Object.entries( this ) )' elementConverter:
		[ :jsEntry | Array with: INLINE 'stString$class.$fromJs$( jsEntry[ 0 ] )' with: INLINE 'jsEntry[ 1 ]' ].
!

"Comparing"

== object
	"Return true a self and arg refer to the same object."
	^ Boolean fromJs: INLINE 'this === object'.
!
= object
	"Return true a self and arg have the same value.
	 The default is to return object equality.
	 Overload this for composed objects."
	^ self == object.
!
~= object
	^ ( self = object ) not.
!
isNil
	^ false.
!
notNil
	^ self isNil not.
!

"Default cases of (reverse) comparing number types compares to other objects."

argIsEqualToInteger: integer
	^ false.
!
argIsEqualToBigInt: bigInt
	^ false.
!
argIsEqualToFloat: float
	^ false.
!
argIsEqualToFraction: fraction
	^ false.
!

"Error handling"

assert: block
	block value ifFalse: [
		self error: 'Assertion failed: ', block script ].
!
error: message
	Error throw: message.
!
subclassResponsibility
	self error: 'Method should be implemented by subclass.'
!
log: message
	INLINE 'console.log( message.$toString().js )'.
!
yourself
	^ self.
!
halt
	self error: 'Halted.'.
!

"Class testing"

isKindOf: aClass
	^ self class inheritsFrom: aClass.
!
isMemberOf: aClass
	^ self class = aClass.
!
respondsTo: methodName
	^ self class canUnderstand: methodName.
!
ifNil: block
	"I'm not nil, so don't evaluate block."
!
ifNotNil: block
	^ block value.
!

"Methods"

perform: methodName
	^ INLINE 'this[ Naming.methodStToJs( methodName.js ) ]()'.
!
perform: methodName with: argument
	^ INLINE 'this[ Naming.methodStToJs( methodName.js ) ]( argument )'.
!
perform: methodName with: argument1 with: argument2
	^ INLINE 'this[ Naming.methodStToJs( methodName.js ) ]( argument1, argument2 )'.
!
perform: methodName with: argument1 with: argument2 with: argument3
	^ INLINE 'this[ Naming.methodStToJs( methodName.js ) ]( argument1, argument2, argument3 )'.
!
