CLASS Object EXTENDS nil MODULE Core CLASSVARS '' VARS ''

INLINE 'import { Naming } from "./Runtime.js";'

CLASSMETHODS

myTest
	"This is the first method compiled, used when testing the compiler."
	| a |
	a := 1.
	^ a + 2 negated.
!

new
	"The basicNew method is generated by the compiler in each class
	 to instantiate ST objects from their generated JS class."
	^ self basicNew.
!
fromJs: js
	"Return new ST object containing values of argument JS object, recursively."

	| jsClassName float object jsObject |

	INLINE 'if( js == null ) return stNil'.

	jsClassName := String fromJs: INLINE 'js.constructor.name'.

	jsClassName = 'String' ifTrue: [
		^ String fromJs: js ].

	jsClassName = 'Number' ifTrue: [
		"Convert to integer if possible, otherwise float."
		float := Float fromJs: js.
		^ float isSafeInteger ifTrue: [ float toInteger ] ifFalse: [ float ] ].

	jsClassName = 'Boolean' ifTrue: [
		^ Boolean fromJs: js ].

	jsClassName = 'Array' ifTrue: [
		^ Array fromJs: js
			elementConverter: [ :element | Object fromJs: element ] ].

	jsClassName = 'Object' ifTrue: [
		object := Object new.
		jsObject := JsObject fromJs: js.
		jsObject ownJsPropertyNames do: [ :name |
			object atProperty: name put: ( jsObject atJsProperty: name ) ].
		^ object ].

	self error: 'Unknown JS classname: ', jsClassName.
!

METHODS

"Conversion"

toJs
	"Converts self to a JS object.
	 Array overloads this to convert array elements to JS also, recursively.
	 So the resulting object does not contain any smalltalk objects anymore,
	 and is suitable for passing to JS functions, and to convert to JSON."

	| result |

	result := JsObject newEmpty.
	self ownPropertyNames do: [ :name |
		result atJsProperty: name put: ( self atProperty: name ) ].
	^ result js.
!
toJsObject
	"Calls toJs and wraps result in a JsObject."

	^ JsObject fromJs: self toJs.
!

"Properties"

ownPropertyNames
	^ Array fromJs: INLINE 'Object.getOwnPropertyNames( this )' elementClass: String.
!
atProperty: name
	^ Nil fromJs: INLINE 'this[ name.js ]'.
!
atProperty: name put: value
	INLINE 'this[ name.js ] = value'.
!

"Comparing"

== object
	"Return true a self and arg refer to the same object."
	^ Boolean fromJs: INLINE 'this === object'.
!
= object
	"Return true a self and arg have the same value.
	 The default is to return object equality.
	 Overload this for composed objects."
	^ self == object.
!
~= object
	^ ( self = object ) not.
!
isNil
	^ false.
!
notNil
	^ self isNil not.
!

"Default cases of (reverse) comparing number types compares to other objects."

argIsEqualToInteger: integer
	^ false.
!
argIsEqualToBigInt: bigInt
	^ false.
!
argIsEqualToFloat: float
	^ false.
!
argIsEqualToFraction: fraction
	^ false.
!

"Converting"

toString
	^ 'a ', self class name.
!
toLocaleString
	^ self toString.
!

"Error handling"

error: message
	Error throw: message.
!
log: message
	INLINE 'console.log( message.$toString().js )'.
!
yourself
	^ self.
!
halt
	self error: 'Halted.'.
!

"Class testing"

isKindOf: aClass
	^ self class inheritsFrom: aClass.
!
isMemberOf: aClass
	^ self class = aClass.
!

"Methods"

perform: methodName
	^ INLINE 'this[ Naming.methodStToJs( methodName.js ) ]()'.
!
perform: methodName with: argument
	^ INLINE 'this[ Naming.methodStToJs( methodName.js ) ]( argument )'.
!
perform: methodName with: argument1 with: argument2
	^ INLINE 'this[ Naming.methodStToJs( methodName.js ) ]( argument1, argument2 )'.
!
perform: methodName with: argument1 with: argument2 with: argument3
	^ INLINE 'this[ Naming.methodStToJs( methodName.js ) ]( argument1, argument2, argument3 )'.
!

"JSON"

fetchObject: url then: block onError: errorBlock
	"Retuns a ST object from the the fetched JSON response."
	INLINE '
		fetch( url.js )
			.then( response => response.json() )
			.then( js => block.$value$( stObject$class.$fromJs$( js ) ) )
			.catch( error => errorBlock.$value$( stError$class.$fromJs$( error ) ) )'.
!
parse: json
	^ Object fromJs: INLINE 'JSON.parse( json.js )'.
!
